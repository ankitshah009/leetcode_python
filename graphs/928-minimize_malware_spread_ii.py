#928. Minimize Malware Spread II
#Hard
#
#You are given a network of n nodes as an adjacency matrix graph, and an array
#initial containing nodes initially infected by malware.
#
#Malware spreads when an infected node is directly connected to another node.
#
#We will remove exactly one node from initial, removing all edges connected to
#it. Return the node that, if removed, would minimize M(initial).
#
#If multiple nodes could minimize M(initial), return the one with smallest index.
#
#Constraints:
#    n == graph.length
#    n == graph[i].length
#    2 <= n <= 300
#    graph[i][j] is 0 or 1.
#    graph[i][j] == graph[j][i]
#    graph[i][i] == 1
#    1 <= initial.length <= n

class Solution:
    def minMalwareSpread(self, graph: list[list[int]], initial: list[int]) -> int:
        """
        For each infected node, count clean nodes it uniquely reaches.
        """
        n = len(graph)
        initial_set = set(initial)
        clean_nodes = [i for i in range(n) if i not in initial_set]

        # Build clean node graph
        parent = {i: i for i in clean_nodes}
        rank = {i: 0 for i in clean_nodes}

        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(x, y):
            px, py = find(x), find(y)
            if px == py:
                return
            if rank[px] < rank[py]:
                px, py = py, px
            parent[py] = px
            if rank[px] == rank[py]:
                rank[px] += 1

        # Union clean nodes
        for i in clean_nodes:
            for j in clean_nodes:
                if graph[i][j]:
                    union(i, j)

        # Count component sizes
        from collections import Counter
        comp_size = Counter(find(i) for i in clean_nodes)

        # For each clean component, find which infected nodes can reach it
        comp_infected = {find(i): [] for i in clean_nodes}
        for infected in initial:
            reached_comps = set()
            for clean in clean_nodes:
                if graph[infected][clean]:
                    reached_comps.add(find(clean))
            for comp in reached_comps:
                comp_infected[comp].append(infected)

        # Count nodes saved by removing each infected node
        saved = Counter()
        for comp, infected_list in comp_infected.items():
            if len(infected_list) == 1:
                # This component is only reachable by one infected node
                saved[infected_list[0]] += comp_size[comp]

        # Find best node to remove
        result = min(initial)
        max_saved = 0

        for node in initial:
            if saved[node] > max_saved or (saved[node] == max_saved and node < result):
                max_saved = saved[node]
                result = node

        return result


class SolutionDFS:
    """DFS approach"""

    def minMalwareSpread(self, graph: list[list[int]], initial: list[int]) -> int:
        n = len(graph)
        initial_set = set(initial)

        # For each clean node, find which infected nodes can reach it via clean path
        from collections import defaultdict

        def bfs_from_infected(start):
            """BFS from infected node through graph, return reached clean nodes."""
            visited = {start}
            queue = [start]
            reached = set()

            while queue:
                node = queue.pop(0)
                for neighbor in range(n):
                    if graph[node][neighbor] and neighbor not in visited:
                        visited.add(neighbor)
                        if neighbor in initial_set:
                            continue  # Don't go through other infected
                        reached.add(neighbor)
                        queue.append(neighbor)

            return reached

        # For each infected node, find clean nodes only it can infect
        reach = {}
        for inf in initial:
            reach[inf] = bfs_from_infected(inf)

        # Count nodes uniquely reached by each infected
        saved = defaultdict(int)
        all_clean = set(range(n)) - initial_set

        for clean in all_clean:
            reachable_by = [inf for inf in initial if clean in reach[inf]]
            if len(reachable_by) == 1:
                saved[reachable_by[0]] += 1

        result = min(initial)
        max_saved = 0

        for node in initial:
            if saved[node] > max_saved or (saved[node] == max_saved and node < result):
                max_saved = saved[node]
                result = node

        return result
