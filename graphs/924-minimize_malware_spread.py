#924. Minimize Malware Spread
#Hard
#
#You are given a network of n nodes as an adjacency matrix graph, and an array
#initial containing nodes initially infected by malware.
#
#Whenever two nodes are directly connected, and at least one is infected, both
#become infected. This spread continues until no more nodes can be infected.
#
#Suppose M(initial) is the final number of infected nodes after the spread.
#
#We will remove exactly one node from initial, completely removing it from the
#graph. Return the node that, if removed, would minimize M(initial). If multiple
#nodes could be removed to minimize M(initial), return the one with the smallest
#index.
#
#Constraints:
#    n == graph.length
#    n == graph[i].length
#    2 <= n <= 300
#    graph[i][j] is 0 or 1.
#    graph[i][j] == graph[j][i]
#    graph[i][i] == 1
#    1 <= initial.length <= n
#    0 <= initial[i] <= n - 1
#    All the integers in initial are unique.

class Solution:
    def minMalwareSpread(self, graph: list[list[int]], initial: list[int]) -> int:
        """
        Union-Find: removing a node helps only if it's the sole infected node
        in its component.
        """
        n = len(graph)
        initial_set = set(initial)

        # Union-Find
        parent = list(range(n))
        rank = [0] * n

        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(x, y):
            px, py = find(x), find(y)
            if px == py:
                return
            if rank[px] < rank[py]:
                px, py = py, px
            parent[py] = px
            if rank[px] == rank[py]:
                rank[px] += 1

        # Build components
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j]:
                    union(i, j)

        # Count component sizes
        component_size = {}
        for i in range(n):
            root = find(i)
            component_size[root] = component_size.get(root, 0) + 1

        # Count infected nodes per component
        infected_count = {}
        for node in initial:
            root = find(node)
            infected_count[root] = infected_count.get(root, 0) + 1

        # Find node whose removal saves most nodes
        result = min(initial)
        max_saved = 0

        for node in initial:
            root = find(node)
            if infected_count[root] == 1:
                # This is the only infected node in its component
                saved = component_size[root]
                if saved > max_saved or (saved == max_saved and node < result):
                    max_saved = saved
                    result = node

        return result


class SolutionDFS:
    """DFS to find components"""

    def minMalwareSpread(self, graph: list[list[int]], initial: list[int]) -> int:
        n = len(graph)
        initial_set = set(initial)

        # Find connected components
        visited = [False] * n
        component = [-1] * n
        component_id = 0

        def dfs(node, comp_id):
            component[node] = comp_id
            for neighbor in range(n):
                if graph[node][neighbor] and not visited[neighbor]:
                    visited[neighbor] = True
                    dfs(neighbor, comp_id)

        for i in range(n):
            if not visited[i]:
                visited[i] = True
                dfs(i, component_id)
                component_id += 1

        # Count component sizes and infected per component
        from collections import Counter
        comp_size = Counter(component)
        comp_infected = Counter(component[node] for node in initial)

        result = min(initial)
        max_saved = 0

        for node in initial:
            comp = component[node]
            if comp_infected[comp] == 1:
                saved = comp_size[comp]
                if saved > max_saved or (saved == max_saved and node < result):
                    max_saved = saved
                    result = node

        return result
